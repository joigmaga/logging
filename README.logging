/*
A basic logging interface

    Ignacio Martinez (igmartin@movistar.es)
    January 2023

*/

///////////////////////////// 
//
// A basic logging facility modelled upon the "logging" Python module
//
///////////// Introduction to the user interface
//
// Access to all interface methods through a tiny object containing
// only a smart pointer to the actual logger
// The smart pointer returned in the Logger is always the same for
// a logger of name "name"
//
// the Logger and Formatter classes
//
//   Logger logger = Logger::get_logger("name")  // logger for entitity "name" 
//   Logger root_logger = Logger::get_logger()   // the root logger
//
//   Formatter Formatter::get_formatter(time_format=DEFAULT_TIMEFMT,
//                                      record_format=DEFAULT_RECORDFMT,
//                                      end_of_line=true)
//
//
///////////// LoggerTree class
//
// LoggerTree objects are internal loggers with all the attributes required to
// create and mantain a logging hierarchy
// LoggerTree instances are opaque to the user and are accessible only through
// loggers, which are 'views' into the logger tree hierarchy

///////////// Logger class
//
// Logger instances are dynamic objects built internally using smart pointers
// for efficient memory management
// Formatter instances can be members of the Logger class and are responsible
// for the final output layout of logging records
//
// Module duration is tied to storage duration of the returned (smart) pointer
// within loggers
// Loggers get instantiated using a factory function (get_logger(module))
// Loggers form a hierarchy. There is a 'root' Logger that gets instantiated
// automatically and can be modified later
// Once a logger is out of scope, the object pointed to is destroyed and the
// instance tree is rebuilt
//
// User interface
//
//   logger creation through static factory functions:
//
//     Logger logger = Logger::get_logger(const string& name,
//                                        int level,      // optional         
//                                        int streamer)   // optional
//
//     Logger logger = Logger::get_logger(int level,      // optional         
//                                        int streamer)   // optional
//
//         - level is the log level and can be one of:
//               NOTSET, DEBUG, INFO, WARNING, ERROR, CRITICAL, UNCHANGED
//           the special value of NOTSET prevents any logging output
//           the special value of UNCHANGED does not alter the current setting 
//         - streamer opens an output stream for the logger and can be one of:
//               STDOUT, STDERR, STDLOG, DEVNULL
//
//  formatter creation:
//
//    Formatter formatter = Formatter::get_formatter(
//                             const string& recfmt,    // optional
//                             const string& timefmt,   // optional
//                             bool eol)                // optional
//
//         - recfmt is the record format. Expansions include:
//                 default value is "%t %I[%l] %N%m"   (DEFAULT_RECORDFMT)
//                     %t -- time format (see below)
//                     %i -- thread id (hash value)
//                     %I -- skip if main thread otherwise enclose in "()"
//                     %l -- log level as a lowercase string
//                     %L -- log level as an uppercase string
//                     %N -- logger name folowed by ": " if not empty
//                     %n -- logger name
//                     %m -- log message
//         - timefmt is the time format. Uses the strftime(3) expansions
//                 default value is "%Y/%m/%d:%H:%M:%S" (DEFAULT_TIMEFMT)
//         - eol is a flag that enables/inhibits the output of a final LF
//                 default value is 'true'
//
//  public logger methods:
//
//    - Factory functions for instatiating the class
//        static Logger Logger::get_logger(const string& module,
//                          int level=UNCHANGED, int stream=UNCHANGED)
//    - Naming
//        void Logger::set_alias(const string& module)
//    - Formatter handling
//        Formatter& Logger::get_formatter()
//        void Logger::set_formatter(Formatter& ref_formatter)
//    - Message dispatch
//        void Logger::log(int level, const char* format, ...)
//        void Logger::autolog(int level, const char* format, ...)
//        void Logger::critical(const char* format, ...)
//        void Logger::error(const char* format, ...)
//        void Logger::warning(const char* format, ...)
//        void Logger::info(const char* format, ...)
//        void Logger::debug(const char* format, ...)
//    - Get/set current log level
//        int Logger::get_loglevel()
//        int Logger::set_loglevel(int level)
//        int Logger::get_effective_loglevel()
//    - Select log file and streamer
//        int Logger::set_logfile(const string& fname)
//        ostream* Logger::get_streamer()
//        ostream* Logger::set_streamer(int streamval)
//        ostream* Logger::set_streamer(ostream* streamer)
//    - Control tree navigation
//        bool Logger::set_propagation(bool mode)
//    - Auto log
//        static bool Logger::get_autolog()
//        static bool Logger::set_autolog(bool mode)
//
//  public logger methods:
//
//    - Factory functions for instantiating the class
//        static Formatter Formatter::get_formatter(
//                                  const string& recfmt = DEFAULT_RECORDFMT,
//                                  const string& timefmt = DEFAULT_TIMEFMT,
//                                  bool eol = true)
//
//    - Formatter settings
//        void Formatter::set_timefmt(const string& timefmt)
//        void Formatter::set_recfmt(const string& recfmt)
//        void Formatter::set_eol(const bool eol)
//
//  one can create logger hierarchies using names separated by '.'
//
//      Logger logger = Logger::get_logger("myapp", WARNING, STDLOG);
//      Logger logger = Logger::get_logger("myapp.util", DEBUG, STDERR);
//
//  in such a case, records created by 'myapp.util' will be logged at
//  'myapp.util' and 'myapp' level, with the corresponding level and stream
//  settings, while 'myapp' will use only the 'myapp' logger.
//  This can be further controlled by 'propagation' setting in the logger
//      
//  usage:
//
//    using default formatting
//
//      Logger logger = Logger::get_logger("myapp", WARNING, STDLOG);
//      logger.error("I have a strong pain in my %s", "head");
//      
//    using a specific formatter
//
//      Logger logger = Logger::get_logger("myapp", WARNING, STDLOG);
//      Formatter formatter = Formatter::get_formatter("%t (%i) [%l] %n %m");
//      logger.set_formatter(formatter);
//      logger.log(ERROR, "I have a strong pain in my %s", "head");
//
///////////// logging namespace
//
// Non-local variables are kept in a separate namespace (logging)
// Those include the main thread of execution and various mutexes
//
//   Identifies the default thread of execution
//   Must get initialized before any thread is launched
//
//     logging::main_thread_id = this_thread::get_id()
//
//   Flag to allow debugging of internal operations using regular loggers
//
//     logging::autolog
//
//   Mutexes are placed in a separate namespace
//   Must last until other dynamic objects are destroyed
//
//     logging::treemutex   protect logger tree operations
//     logging::filemutex   protect file and stream operations
//     logging::logmutex    protect message creation and delivery
//     logging::fmtmutex    protect formatter creation and manipulation
//
